= PXD

Pxd is a plain text human readable storage format that may serve as a
convenient alternative to csv, ini, json, sqlite, toml, xml, or yaml.

Note that `.pxd` files are always UTF-8-encoded and may optionally be
gzip-compressed.

== Datatypes

Pxd supports ten datatypes.

[cols="1,5"]
|===
|**Type**   |**Example(s) # notes**
|null       |`null`
|bool       |`no` `false` `yes` `true`
|int        |`-192` `+234` `7891409`
|real       |`0.15` `0.7e-9` `2245.389` # a decimal point with at least
one digit before and after
|date       |`2022-04-01`  # ISO8601
|datetime   |`2022-04-01T16:11::51` `2022-04-01T16:11::51Z` # ISO8601
|str        |`<Some text which may include newlines>` # see BNF below
|bytes      |`(20AC 65 66 48)` # must be even number of hex digits; whitespace optional
|list       |`[value1 value2 ... valueN]`
|dict       |`{key1 value1 key2 value2 ... keyN valueN}`
|===

Dictionary keys may only be of types `int`, `date`, `datetime`, `str`,
and `bytes`.

== Examples

=== Minimal empty pxd

    pxd 1.0

=== CSV to pxd

==== CSV

    Date,Price,Quantity,ID,Description
    2017-09-21,3.99,2,"CH1-A2","Chisels (pair), 1in & 1¼in"
    2017-10-02,4.49,1,"H2-K9","Hammer, 2lb"
    2017-10-02,5.89,1,"SX4-D1","Eversure Sealant, 13-floz"

==== PXD Equivalent

    pxd 1.0 Price List
    [
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13-floz>]
    ]

Here the data is simply a `list` of ``list``s.

However, it is more conventional to make the first `list` in a `list` of
`lists` a `list` of field names:

    pxd 1.0 Price List
    [
        [<Date> <Price> <Quantity> <ID> <Description>]
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13-floz>]
    ]

=== INI to pxd

==== INI

    shapename = Hexagon
    zoom = 150
    showtoolbar = False
    [Window]
    x=615
    y=252
    width=592
    height=636
    scale=1.1
    [Files]
    current=test1.pxd
    recent1=/tmp/test2.pxd
    recent2=C:\Users\mark\test3.pxd

==== PXD Equivalent

    pxd 1.0 MyApp 1.2.0 Config
    {
        <General> {<shapename> <Hexagon> <zoom> 150 <showtoolbar> no}
        <Window> {<x> 615 <y> 252 <width> 592 <height> 636 <scale> 1.1}
        <Files> {<current> <test1.pxd>
                 <recent1> </tmp/test2.pxd>
                 <recent2> <C:\Users\mark\test3.pxd>}
    }

For configuration data it is often convenient to use ``dict``s with name
keys and data values. In this case the overall data is a `dict` which
contains each configuration file section, and the value of each of this
``dict``s keys is itself a `dict`.

Of course, we can nest as deep as we like and mix ``dict``s and lists.
For example, here's an alternative:

    pxd 1.0 MyApp 1.2.0 Config
    {
        <General> {
            <shapename> <Hexagon> <zoom> 150 <showtoolbar> no
            <Files> {<current> <test1.pxd>
                     <recent> [</tmp/test2.pxd> <C:\Users\mark\test3.pxd>]}
        }
        <Window> {<x> 615 <y> 252 <width> 592 <height> 636 <scale> 1.1}
    }

Here, we've moved the _Files_ into _General_ and changed the recent
files from per-file `dict` items into a `list` of filenames.

=== Database to pxd

Data-wise a database normally consists of one or more tables. A pxd
equivalent using a `dict` of ``list``s is easily made.

    pxd 1.0 MyApp Data
    {
        <Customer> [
            [<CID> <Company> <Address> <Contact> <Email>]
            [50 <Best People> <123 Somewhere> <John Doe> <j@doe.com>]
            [19 <Supersuppliers> null <Jane Doe> <jane@super.com>]
        ]
        <Invoice> [
            [<INUM> <CID> <Raised Date> <Due Date> <Paid> <Description>]
            [152 50 2022-01-17 2022-02-17 false <COD>]
            [153 19 2022-01-19 2022-02-19 true <>]
        ]
        <Item> [
            [<IID> <INUM> <Delivery Date> <Unit Price> <Quantity> <Description>]
            [1839 152 2022-01-16 29.99 2 <Bales of hay>]
            [1840 152 2022-01-16 5.98 3 <Straps>]
            [1620 153 2022-01-19 11.50 1 <Washers (1-in)>]
        ]
    }

Here we have a `dict` where each keys' items are a `list` of ``list``s
representing three database tables. As is conventional we make the first
`list` in each `list` of ``list``s a `list` of field names.

Notice that the second customer has a `null` address and the second
invoice has an empty description.

== BNF

A `.pxd` file consists of a mandatory header followed by a single
optional `dict`, `list`, or `records`.

    PXD      ::= 'pxd' RWS REAL CUSTOM? '\n' DATA?
    CUSTOM   ::= RWS [^\n]+ # user-defined data e.g. filetype and version
    DATA     ::= (DICT | LIST)
    DICT     ::= '{' OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS '}'
    LIST     ::= '[' OWS VALUE? (RWS VALUE)* OWS ']'
    KEY      ::= (INT | DATE | DATETIME | STR | BYTES)
    VALUE    ::= (NULL | BOOL | INT | REAL | DATE | DATETIME | STR |
                  BYTES | LIST | DICT)
    NULL     ::= 'null'
    BOOL     ::= 'no' | 'false' | 'yes' | 'true'
    INT      ::= /[-+]?\d+/
    REAL     ::= # support both standard and scientific
    DATE     ::= /\d\d\d\d-\d\d-\d\d/ # must be a valid date
    DATETIME ::= /\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d)?(Z|[-+]\d\d(:?[:]?\d\d)?)?/ # must be a valid date
    STR      ::= /[<][^<>]*[>]/ # newlines and &amp; &lt; &gt; supported i.e., XML
    BYTES    ::= '(' (OWS [A-Fa-f0-9]{2})* OWS ')'
    OWS      ::= /[\s\n]*/
    RWS      ::= /[\s\n]+/

A `pxd` reader should be able to read a plain text or gzipped plain text
`pxd` file.
