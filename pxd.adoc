= PXD

Pxd is a plain text human editable optionally typed storage format that
may serve as a convenient alternative to csv, ini, json, sqlite, toml,
xml, or yaml.

== Datatypes

[cols="1,5"]
|===
|**Type**   |**Example(s) and notes**
|none       |`none`
|bool       |`false` `true`
|int        |`-192` `+234` `7891409`
|real       |`0.15` `0.7e-9` `2245.389`
|date       |`2022-04-01`  # ISO8601
|datetime   |`2022-04-01T16:11::51` `2022-04-01T16:11::51Z` # ISO8601
|text       |`"Some text which may include escapes"` # see notes below
|bytes      |`<20AC 65 66 48>` # must be even number of digits; whitespace optional
|list       |`[value1 value2 ... valueN]`
|typedlist  |`valuetypename[value1 value2 ... valueN]`
|dict       |`{key1 value1 key2 value2 ... keyN valueN}`
|typeddict  |`valuetypename{key1 value1 key2 value2 ... keyN valueN}`
|record     |`recordname(value1 value2 ... valueN)`
|recordlist |`recordname[recordbody1 recordbody2 ... recordbodyN]`
|recorddict |`recordname{key1 recordbody1 key2 recordbody2 ... keyN recordbodyN}`
|===

== Examples

=== Minimal empty pxd

    pxd 1.0

=== CSV to pxd

==== CSV

    Date,Price,Quantity,ID,Description
    2017-09-21,3.99,2,"CH1-A2","Chisel, 1in"
    2017-10-02,4.49,1,"H2-K9","Hammer, 2lb"
    2017-10-02,5.89,1,"SX4-D1","Eversure Sealant, 13floz"

==== PXD Equivalent

    pxd 1.0 Price List
    defs[
    Item{"Date" date "Price" real "Quantity" int "ID" text "Description" text}
    ][
    Item[ # recordlist, i.e., a list of heterogeneous records
        (2017-09-21 3.99 2 "CH1-A2" "Chisel, 1in")
        (2017-10-02 4.49 1 "H2-K9" "Hammer, 2lb")
        (2017-10-02 5.89 1 "SX4-D1" "Eversure Sealant, 13floz")
    ]
    ]

=== INI to pxd

==== INI

    shapename = Hexagon
    zoom = 150
    showtoolbar = False
    [Window]
    x=615
    y=252
    width=592
    height=636

==== PXD Equivalent (untyped)

    pxd 1.0 MyApp Config
    {
        "General" {"shapename" "Hexagon" "zoom" 150 "showtoolbar" false}
        "Window" {"x" 615 "y" 252 "width" 592 "height" 636}
    }

Since no record types are used no `recorddefs` entry is needed.

==== PXD Equivalent (typed)

    pxd 1.0 MyApp Config
    defs[
        General{"shapename" text "zoom" int "showtoolbar" bool"}
        Window{"x" int "y" int "width" int "height" int}
    ][ # list of heterogeneous records
        General("Hexagon" 150 false)
        Window(615 252 592 636)
    ]

=== Database to pxd

    pxd 1.0 MyApp Data
    defs[
        Customer{"cid" int "organization" text "address" text "contact" text "phone" text "email" text}
        Invoice{"inum" int "cid" int "raised" date "due" date "paid" bool "description" text}
        Item{"iid" int "inum" int "date" date "price" real "quantity" int "description" text}
    ][ # list of recordlists
        Customer[
            (50 "Best People" "123 Somewhere" "John Doe" "" "j@doe.com")
            (19 "Supersuppliers" "" "Jane Doe" "" "jane@super.com")
        ]
        Invoice[
            (152 50 2022-01-17 2022-02-17 false "COD")
            (153 19 2022-01-19 2022-02-19 true "COD")
        ]
        Item[
            (1839 152 2022-01-16 29.99 2 "Bales of hay")
            (1840 152 2022-01-16 5.98 3 "Straps")
            (1620 153 2022-01-19 11.50 1 "Washers (1-in)")
        ]
    ]

== BNF

A `.pxd` file consists of a single untyped `dict` with a first mandatory
key of `pxd` and a `list` value whose first entry is an `int` PXD
version number. Any subsequent entries are for custom data, for example
to identify a custom PXD format. The second entry is optional and if
present uses the key `recorddefs` and has a `list` value where each item
specifies a typed record. The third entry is also optional and if
present uses the key `data` and has a value which is a `list`, `dict`,
`recordlist`, `recorddict`, or a single `record`.

### TODO FIXME

    PXD        ::= pxd RWS REAL (OWS DEFS)? OWS DATA? OWS
    DEFS       ::= OWS 'defs' OWS '[' RECORDDEF (OWS RECORDDEF)* ']'
    RECORDDEF  ::= RECORDIDENTIFIER OWS
                   '{' OWS RECORDIDENTIFIER RWS TYPENAME ('[]' | '{}')?
                       (RWS RECORDIDENTIFIER RWS TYPENAME ('[]' | '{}')?)* '}'
	    # If [] follows a typename it means list of this type; if {}
	    # follows a typename it means dict whose values are of this type
    DATA       ::= OWS (LIST | DICT | TYPEDLIST | RECORDLIST | RECORDDICT |
                    RECORD)
    LIST       ::= '[' OWS VALUE? (RWS VALUE)* OWS ']'
    DICT       ::= '{' OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS '}'
    TYPEDLIST ::= ('int' | 'date' | 'datetime' | 'bytes' |
                   'real' | 'text') LIST
    RECORDLIST ::= IDENTIFIER LIST
    RECORDDICT ::= IDENTIFIER DICT
    KEY        ::= INT | DATE | TEXT
    VALUE      ::= KEY | NONE | BOOL | REAL | BYTES | LIST | DICT
                |  RECORD | TYPEDLIST | RECORDLIST | RECORDDICT | DATETIME
    INT               ::= /[-+]?\d+/
    DATE       ::= /\d\d\d\d-\d\d-\d\d/ # must be a valid date
    DATETIME   ::= /\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d)?(Z|[-+]\d\d(:?[:]?\d\d)?)?/ # must be a valid date
    TEXT       ::= /"[^"]*"/ # plus handle escapes:
            # /[^]([nt^]|x[A-Fa-f0-9]{2}|u[A-Fa-f0-9]{4}|U[A-Fa-f0-9]{6}/
    NONE       ::= 'none'
    BOOL       ::= 'false' | 'true'
    REAL       ::= ### normal + scientific
    BYTES      ::= '<' (OWS [A-Fa-f0-9]{2})* OWS '>'
    RECORD     ::= IDENTIFIER '(' OWS VALUE (RWS VALUE)* ')'
                   # must be correct number of VALUEs of the correct types
    RECORDIDENTIFIER ::= /\p{Lu}[\w.]*/ # must start with uppercase
    IDENTIFIER ::= /\p{L}[\w.]*/
    OWS        ::= /[\s\n]*/
    RWS        ::= /[\s\n]+/

Plus comments (`#` followed by text) are allowed at ends of lines but
are not preserved.

A `pxd` reader should be able to read a plain text or gzipped plain text
`pxd` file.
