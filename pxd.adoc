= PXD

Pxd is a plain text human readable optionally typed storage format that
may serve as a convenient alternative to csv, ini, json, sqlite, toml,
xml, or yaml.

Note that `.pxd` files are always UTF-8-encoded.

== Datatypes

[cols="1,5"]
|===
|**Type**   |**Example(s) and notes**
|none       |`none`
|bool       |`false` `true`
|int        |`-192` `+234` `7891409`
|real       |`0.15` `0.7e-9` `2245.389`
|date       |`2022-04-01`  # ISO8601
|datetime   |`2022-04-01T16:11::51` `2022-04-01T16:11::51Z` # ISO8601
|str        |`<Some text which may include newlines>` # see BNF below
|bytes      |`(20AC 65 66 48)` # must be even number of hex digits; whitespace optional
|list       |`[value1 value2 ... valueN]`
|records    |`Identifier[ +
                [value1a value2a ... valueNa] +
                [value1b value2b ... valueNb] +
                               : +
                [value1z value2z ... valueNz] +
             ]`
|dict       |`{key1 value1 key2 value2 ... keyN valueN}`
|===

Dictionary keys may only be of types `int`, `date`, `datetime`, `str`,
and `bytes`. Record identifiers are created by `def` statements and
always start with a capital letter (see examples below).

== Examples

=== Minimal empty pxd

    pxd 1.0

=== CSV to pxd

==== CSV

    Date,Price,Quantity,ID,Description
    2017-09-21,3.99,2,"CH1-A2","Chisels (pair), 1in & 1¼in"
    2017-10-02,4.49,1,"H2-K9","Hammer, 2lb"
    2017-10-02,5.89,1,"SX4-D1","Eversure Sealant, 13floz"

==== PXD Equivalent using simple implicitly typed lists

    pxd 1.0 Price List
    [
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13floz>]
    ]

Here the data is simply a `list` of ``list``s.

==== PXD Equivalent using explicitly typed and named records

    pxd 1.0 Price List
    def PriceList {<Date> date <Price> real <Quantity> int <ID> str <Description> str}
    PriceList[
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13floz>]
    ]

Now we have a list of _records_ each of type `PriceList`.

=== INI to pxd

==== INI

    shapename = Hexagon
    zoom = 150
    showtoolbar = False
    [Window]
    x=615
    y=252
    width=592
    height=636
    scale=1.0
    [Files]
    current=test1.pxd
    recent1=/tmp/test2.pxd
    recent2=C:\Users\mark\test3.pxd

==== PXD Equivalent using simple implicitly typed dicts

    pxd 1.0 MyApp 1.2.0 Config
    {
        <General> {<shapename> <Hexagon> <zoom> 150 <showtoolbar> false}
        <Window> {<x> 615 <y> 252 <width> 592 <height> 636 <scale> 1.0}
        <Files> {<current> <test1.pxd>
                 <recent1> </tmp/test2.pxd>
                 <recent2> <C:\Users\mark\test3.pxd>}
    }

Here we've used a `dict` whose values are themselves ``dict``s.

==== PXD Equivalent using explicitly typed and named records

    pxd 1.0 MyApp 1.2.0 Config
    def General {<shapename> str <zoom> int <showtoolbar> bool}
    def Window {<x> int <y> int <width> int <height> int <scale> real}
    def File {<which> str <filename> str}
    [
        General[[<Hexagon> 150 false]]
        Window[[615 252 592 636 1.0]]
        File[
            [<current> <test1.pxd>]
            [<recent1> </tmp/test2.pxd>]
            [<recent2> <C:\Users\mark\test3.pxd>]
        ]
    }

Here we have created a list of three values, each a _record_ type. For
both `General` and `Window` we only have a single value for each, hence
the double brackets (outer for the list of `General` or `Window`
records, and inner for the one and only particular record). This
structure is clearer for the `File` record type where we have a list of
`File` records that has three records rather than just one.

==== PXD Equivalent -- an alternative nesting Files withing General

    pxd 1.0 MyApp 1.2.0 Config
    def General {<shapename> str <zoom> int <showtoolbar> bool <files> File}
    def File {<which> str <filename> str}
    def Window {<x> int <y> int <width> int <height> int <scale> real}
    [
        General[
            [<Hexagon> 150 false File[
                [<current> <test1.pxd>]
                [<recent1> </tmp/test2.pxd>]
                [<recent2> <C:\Users\mark\test3.pxd>]
                ]
            ]
        ]
        Window[[615 252 592 636 1.0]]
    }

=== Database to pxd

    pxd 1.0 MyApp Data
    def Customer {<cid> int <organization> str <address> str <contact> str <phone> str <email> str}
    def Invoice {<inum> int <cid> int <raised> date <due> date <paid> bool <description> str}
    def Item {<iid> int <inum> int <date> date <price> real <quantity> int <description> str}
    [
        Customer[
            [50 <Best People> <123 Somewhere> <John Doe> <> <j@doe.com>]
            [19 <Supersuppliers> <> <Jane Doe> <> <jane@super.com>]
        ]
        Invoice[
            [152 50 2022-01-17 2022-02-17 false <COD>]
            [153 19 2022-01-19 2022-02-19 true <COD>]
        ]
        Item[
            [1839 152 2022-01-16 29.99 2 <Bales of hay>]
            [1840 152 2022-01-16 5.98 3 <Straps>]
            [1620 153 2022-01-19 11.50 1 <Washers (1-in)>]
        ]
    ]

Here we have a list of three lists equivalent to three database tables.

== BNF

A `.pxd` file consists of a mandatory header followed by a single
optional `dict`, `list`, or `records`.

    PXD         ::= 'pxd' RWS REAL CUSTOM? '\n' DEFS? DATA?
    CUSTOM      ::= RWS [^\n]+ # user-defined data e.g. filetype and version
    DEFS        ::= DEF (OWS DEF)*
    DEF         ::= 'def' RWS IDENTIFIER OWS
                    '{' OWS STR RWS TYPENAME (RWS STR RWS TYPENAME)* OWS '}'
    DATA        ::= (DICT | LIST | RECORDS)
    DICT        ::= '{' OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS '}'
    LIST        ::= '[' OWS VALUE? (RWS VALUE)* OWS ']'
    RECORDS     ::= TYPENAME '[' OWS RECORDVALUE? (RWS RECORDVALUE)* OWS ']'
    RECORDVALUE ::= '[' OWS VALUE (RWS VALUE)* OWS ']' # one value per type
    TYPENAME    ::= ('bool' | 'int' | 'real' | 'date' | 'datetime' | 'str' | 'bytes' |
                     'list' | 'dict' | IDENTIFIER) # IDENTIFIER created by def
    KEY         ::= (INT | DATE | DATETIME | STR | BYTES)
    VALUE       ::= (NONE | BOOL | INT | REAL | DATE | DATETIME | STR | BYTES |
                     LIST | DICT | RECORDS)
    IDENTIFIER  ::= /\p{Lu}\w{,32}/
    NONE        ::= 'none'
    BOOL        ::= 'false' | 'true'
    INT         ::= /[-+]?\d+/
    REAL        ::= # support both standard and scientific
    DATE        ::= /\d\d\d\d-\d\d-\d\d/ # must be a valid date
    DATETIME    ::= /\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d)?(Z|[-+]\d\d(:?[:]?\d\d)?)?/ # must be a valid date
    STR         ::= /[<][^<>]*[>]/ # newlines and &amp; &lt; &gt; supported i.e., XML
    BYTES      ::= '(' (OWS [A-Fa-f0-9]{2})* OWS ')'
    OWS         ::= /[\s\n]*/
    RWS         ::= /[\s\n]+/

Plus comments (`#` followed by text) are allowed at ends of lines but
are not preserved.

A `pxd` reader should be able to read a plain text or gzipped plain text
`pxd` file.
