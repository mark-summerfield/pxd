= PXD

Pxd is a plain text human editable optionally typed storage format that
may serve as a convenient alternative to csv, ini, json, sqlite, toml,
xml, or yaml.

== Datatypes

[cols="1,5"]
|===
|**Type**   |**Example(s) and notes**
|none       |`none`
|bool       |`false` `true`
|int        |`-192` `+234` `7891409`
|real       |`0.15` `0.7e-9` `2245.389`
|date       |`2022-04-01`  # ISO8601
|datetime   |`2022-04-01T16:11::51` `2022-04-01T16:11::51Z` # ISO8601
|text       |`'Some text which may include escapes'` # see notes below
|bytes      |`<20AC 65 66 48>` # must be even number of digits; whitespace optional
|list       |`[value1 value2 ... valueN]`
|dict       |`{key1 value1 key2 value2 ... keyN valueN}`
|record     |`recordname(value1 value2 ... valueN)`
|recordlist |`recordname[recordbody1 recordbody2 ... recordbodyN]`
|recorddict |`recordname{key1 recordbody1 key2 recordbody2 ... keyN recordbodyN}`
|===

== Examples

=== Minimal empty pxd

    {'pxd' [100]}

=== CSV to pxd

==== CSV

    Date,Price,Quantity,ID,Description
    2017-09-21,3.99,2,"CH1-A2","Chisel, 1in"
    2017-10-02,4.49,1,"H2-K9","Hammer, 2lb"
    2017-10-02,5.89,1,"SX4-D1","Eversure Sealant, 13floz"

==== PXD Equivalent

    {'pxd' [100 'Price List']
    'recorddefs' [
        'Item' {'Date' date 'Price' real 'Quantity' int 'ID' text 'Description' text}
    ]
    'data' Item[ # recordlist, i.e., a list of heterogeneous records
        (2017-09-21 3.99 2 'CH1-A2' 'Chisel, 1in')
        (2017-10-02 4.49 1 'H2-K9' 'Hammer, 2lb')
        (2017-10-02 5.89 1 'SX4-D1' 'Eversure Sealant, 13floz')
    ]
    }

=== INI to pxd

==== INI

    shapename = Hexagon
    zoom = 150
    showtoolbar = False
    [Window]
    x=615
    y=252
    width=592
    height=636

==== PXD Equivalent (untyped)

    {'pxd' [100 'MyApp Config']
    'data' { # dict
        'General' {'shapename' 'Hexagon' 'zoom' 150 'showtoolbar' false}
        'Window' {'x' 615 'y' 252 'width' 592 'height' 636}
    }
    }

Since no record types are used no `recorddefs` entry is needed.

==== PXD Equivalent (typed)

    {'pxd' [100 'MyApp Config']
    'recorddefs' [
        'General' {'shapename' text 'zoom' int 'showtoolbar' bool'}
        'Window' {'x' int 'y' int 'width' int 'height' int}
    ]
    'data' [ # list of heterogeneous records
        General('Hexagon' 150 false)
        Window(615 252 592 636)
    ]
    }

=== Database to pxd

    {'pxd' [100 'MyApp Data']
    'recorddefs' [
        'Customer' {'cid' int 'organization' text 'address' text 'contact' text 'phone' text 'email' text}
        'Invoice' {'inum' int 'cid' int 'raised' date 'due' date 'paid' bool 'description' text}
        'Item' {'iid' int 'inum' int 'date' date 'price' real 'quantity' int 'description' text}
    ]
    'data' [ # list of recordlists
        Customer[
            (50 'Best People' '123 Somewhere' 'John Doe' '' 'j@doe.com')
            (19 'Supersuppliers' '' 'Jane Doe' '' 'jane@super.com')
        ]
        Invoice[
            (152 50 2022-01-17 2022-02-17 false 'COD')
            (153 19 2022-01-19 2022-02-19 true 'COD')
        ]
        Item[
            (1839 152 2022-01-16 29.99 2 'Bales of hay')
            (1840 152 2022-01-16 5.98 3 'Straps')
            (1620 153 2022-01-19 11.50 1 'Washers (1-in)')
        ]
    ]
    }

== BNF

A `.pxd` file consists of a single untyped `dict` with a first mandatory
key of `pxd` and a `list` value whose first entry is an `int` PXD
version number. Any subsequent entries are for custom data, for example
to identify a custom PXD format. The second entry is optional and if
present uses the key `recorddefs` and has a `list` value where each item
specifies a typed record. The third entry is also optional and if
present uses the key `data` and has a value which is a `list`, `dict`,
`recordlist`, `recorddict`, or a single `record`.

    PXD        ::= "{" HEADER (OWS RECORDDEFS)? OWS DATA? OWS "}"
    HEADER     ::= "'pxd'" OWS "[" OWS /\d{1,9}/ (RWS TEXT)? OWS "]"
    RECORDDEFS ::= OWS "'recorddefs'" OWS "[" RECORDDEF (OWS RECORDDEF)* "]"
    RECORDDEF  ::= "'" IDENTIFIER "'" OWS
                   "{" OWS IDENTIFIER RWS TYPENAME
                       (RWS IDENTIFIER RWS TYPENAME)* "}"
    DATA       ::= "'data'" OWS
                   (LIST | DICT | RECORDLIST | RECORDDICT | RECORD)
    LIST       ::= "[" OWS VALUE? (RWS VALUE)* OWS "]"
    DICT       ::= "{" OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS "}"
    RECORDLIST ::= IDENTIFIER LIST
    RECORDDICT ::= IDENTIFIER DICT
    KEY        ::= INT | DATE | TEXT
    VALUE      ::= KEY | NONE | BOOL | REAL | BYTES | LIST | DICT
                |  RECORD | RECORDLIST | RECORDDICT | DATETIME
    INT               ::= /[-+]?\d+/
    DATE       ::= /\d\d\d\d-\d\d-\d\d/ # must be a valid date
    DATETIME   ::= /\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d)?(Z|[-+]\d\d(:?[:]?\d\d)?)?/ # must be a valid date
    TEXT       ::= /'[^']*'/ # plus handle escapes:
            # /[^]([nt^]|x[A-Fa-f0-9]{2}|u[A-Fa-f0-9]{4}|U[A-Fa-f0-9]{6}/
    NONE       ::= "none"
    BOOL       ::= "false" | "true"
    REAL       ::= ### normal + scientific
    BYTES      ::= "<" (OWS [A-Fa-f0-9]{2})* OWS ">"
    RECORD     ::= IDENTIFIER "(" OWS VALUE (RWS VALUE)* ")"
                   # must be correct number of VALUEs of the correct types
    IDENTIFIER ::= /\p{L}[\w.]*/
    OWS        ::= /[\s\n]*/
    RWS        ::= /[\s\n]+/

Plus comments (`#` followed by text) are allowed at ends of lines but
are not preserved.
