= PXD

Pxd is a plain text human readable storage format that may serve as a
convenient alternative to csv, ini, json, sqlite, toml, xml, or yaml.

Note that `.pxd` files are always UTF-8-encoded and may optionally be
gzip-compressed.

== Datatypes

Pxd supports eleven datatypes.

[cols="1,5"]
|===
|**Type**   |**Example(s) # notes**
|null       |`null`
|bool       |`no` `false` `yes` `true`
|int        |`-192` `+234` `7891409`
|real       |`0.15` `0.7e-9` `2245.389` # a decimal point with at least
one digit before and after
|date       |`2022-04-01`  # ISO8601
|datetime   |`2022-04-01T16:11::51` `2022-04-01T16:11::51Z` # ISO8601
|str        |`<Some text which may include newlines>` # see BNF below
|bytes      |`(20AC 65 66 48)` # must be even number of hex digits; whitespace optional
|list       |`[value1 value2 ... valueN]`
|fieldnames |`[= <str1> <str2> ... <strN>]` # only needed for ``list``s
of ``list``s
|dict       |`{key1 value1 key2 value2 ... keyN valueN}`
|===

Dictionary keys may only be of types `int`, `date`, `datetime`, `str`,
and `bytes`. The `fieldnames` is a list of ``str``s used to provide
names for the fields in a `list` of ``list``s (see the examples below).

== Examples

=== Minimal empty pxd

    pxd 1.0

=== CSV to pxd

==== CSV

    Date,Price,Quantity,ID,Description
    2017-09-21,3.99,2,"CH1-A2","Chisels (pair), 1in & 1¼in"
    2017-10-02,4.49,1,"H2-K9","Hammer, 2lb"
    2017-10-02,5.89,1,"SX4-D1","Eversure Sealant, 13-floz"

==== PXD Equivalent

    pxd 1.0 Price List
    [
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13-floz>]
    ]

Here the data is simply a `list` of ``list``s.

    pxd 1.0 Price List
    [
        [= <Date> <Price> <Quantity> <ID> <Description>]
        [2017-09-21 3.99 2 <CH1-A2> <Chisels (pair), 1in &amp; 1¼in>]
        [2017-10-02 4.49 1 <H2-K9> <Hammer, 2lb>]
        [2017-10-02 5.89 1 <SX4-D1> <Eversure Sealant, 13-floz>]
    ]

And here we've used `fieldnames` to improve readability.

=== INI to pxd

==== INI

    shapename = Hexagon
    zoom = 150
    showtoolbar = False
    [Window]
    x=615
    y=252
    width=592
    height=636
    scale=1.1
    [Files]
    current=test1.pxd
    recent1=/tmp/test2.pxd
    recent2=C:\Users\mark\test3.pxd

==== PXD Equivalent

    pxd 1.0 MyApp 1.2.0 Config
    {
        <General> {<shapename> <Hexagon> <zoom> 150 <showtoolbar> no}
        <Window> {<x> 615 <y> 252 <width> 592 <height> 636 <scale> 1.1}
        <Files> [
            [= <kind> <filename>]
            [<current> <test1.pxd>]
            [<recent1> </tmp/test2.pxd>]
            [<recent2> <C:\Users\mark\test3.pxd>]
        ]
    }

For configuration data it is often convenient to use ``dict``s with name
keys and data values. In this case the overall data is a `dict` which
contains each configuration section. The value of the first two of the
``dict``s keys is itself a `dict`. But for the third we use a `list` of
``list``s with `fieldnames` for readability.

Of course, we can nest as deep as we like and mix ``dict``s and lists.
For example, here's an alternative:

    pxd 1.0 MyApp 1.2.0 Config
    {
        <General> {
            <shapename> <Hexagon> <zoom> 150 <showtoolbar> no
            <Files> {<current> <test1.pxd>
                     <recent> [</tmp/test2.pxd> <C:\Users\mark\test3.pxd>]}
        }
        <Window> {<x> 615 <y> 252 <width> 592 <height> 636 <scale> 1.1}
    }

Here, we've moved the _Files_ into _General_ and changed the recent
files from per-file `dict` items into a `list` of filenames.

=== Database to pxd

Data-wise a database normally consists of one or more tables. A pxd
equivalent using a `dict` of ``list``s is easily made.

    pxd 1.0 MyApp Data
    {
        <Customer> [
            [= <CID> <Company> <Address> <Contact> <Email>]
            [50 <Best People> <123 Somewhere> <John Doe> <j@doe.com>]
            [19 <Supersuppliers> null <Jane Doe> <jane@super.com>]
        ]
        <Invoice> [
            [= <INUM> <CID> <Raised Date> <Due Date> <Paid> <Description>]
            [152 50 2022-01-17 2022-02-17 false <COD>]
            [153 19 2022-01-19 2022-02-19 true <>]
        ]
        <Item> [
            [= <IID> <INUM> <Delivery Date> <Unit Price> <Quantity> <Description>]
            [1839 152 2022-01-16 29.99 2 <Bales of hay>]
            [1840 152 2022-01-16 5.98 3 <Straps>]
            [1620 153 2022-01-19 11.50 1 <Washers (1-in)>]
        ]
    }

Here we have a `dict` where each keys' items are a `list` of ``list``s
representing three database tables. As is conventional we make the first
item in each `list` of ``list``s `fieldnames` for readability.

Notice that the second customer has a `null` address and the second
invoice has an empty description.

== BNF

A `.pxd` file consists of a mandatory header followed by a single
optional `dict`, `list`, or `records`.

    PXD        ::= 'pxd' RWS REAL CUSTOM? '\n' DATA?
    CUSTOM     ::= RWS [^\n]+ # user-defined data e.g. filetype and version
    DATA       ::= (DICT | LIST)
    DICT       ::= '{' OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS '}'
    LIST       ::= '[' (OWS FIELDNAMES)? OWS VALUE? (RWS VALUE)* OWS ']'
    FIELDNAMES ::= '[=' (OWS STR)+ ']'
    KEY        ::= (INT | DATE | DATETIME | STR | BYTES)
    VALUE      ::= (NULL | BOOL | INT | REAL | DATE | DATETIME | STR |
                    BYTES | LIST | DICT)
    NULL       ::= 'null'
    BOOL       ::= 'no' | 'false' | 'yes' | 'true'
    INT        ::= /[-+]?\d+/
    REAL       ::= # support both standard and scientific
    DATE       ::= /\d\d\d\d-\d\d-\d\d/ # see note below
    DATETIME   ::= /\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d)?(Z|[-+]\d\d(:?[:]?\d\d)?)?/ # see note below
    STR        ::= /[<][^<>]*[>]/ # newlines and &amp; &lt; &gt; supported i.e., XML
    BYTES      ::= '(' (OWS [A-Fa-f0-9]{2})* OWS ')'
    OWS        ::= /[\s\n]*/
    RWS        ::= /[\s\n]+/

Notice that `fieldnames` may only occur as the first item inside a
`list`.

For ``datetime``s, support may vary across different _pxd_ libraries and
might _not_ include timezone support. For example, the Python library
only supports timezones at all if the `dateutil` module is installed,
and then only `Z` (UTC) or an offset (`/[-+]HH(:MM)?/`).

A `pxd` reader should be able to read a plain text or gzipped plain text
`pxd` file.
